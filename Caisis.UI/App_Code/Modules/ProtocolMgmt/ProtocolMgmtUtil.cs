using System;
using System.Data;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Web;
using System.Xml;

using Caisis.BOL;
using Caisis.DataAccess;
using Caisis.Extensions;
using Caisis.UI.Core.Classes;

namespace Caisis.UI.Modules.ProtocolMgmt
{
    /// <summary>
    /// Contains a collection of Protocol related utilities
    /// </summary>
    public class ProtocolMgmtUtil
    {
        public ProtocolMgmtUtil()
        {

        }

        /// <summary>
        /// Gets the ProtocolMgmt config node
        /// </summary>
        /// <returns></returns>
        public static XmlNode GetProtocolConfigurationNode()
        {
            var xDoc = XmlUtil.GetModulesConfigXml();
            return xDoc.SelectSingleNode("//module[@name='Protocol Management']");
        }

        public static float? GetPatientPSADoublingTime(int patientProtocolId)
        {
            float parseResult = 0;
            var labs = PatientProtocolController.GetPatientRelatedRecords<LabTest>(patientProtocolId);
            var psaByDate = from lab in labs
                            where lab[LabTest.LabTest_Field].ToString() == "PSA"
                            where !lab.IsNull(LabTest.LabDate) && !lab.IsNull(LabTest.LabResult)
                            let labResult = lab[LabTest.LabResult].ToString()
                            let labDate = (DateTime)lab[LabTest.LabDate]
                            where float.TryParse(labResult, out parseResult)
                            select new KeyValuePair<float, DateTime>(parseResult, labDate);
            return GetPSADoublingTime(psaByDate);
        }

        /// <summary>
        /// Returns the PSA Doubling Time in months
        /// </summary>
        /// <param name="psaAndDates"></param>
        /// <returns></returns>
        public static float? GetPSADoublingTime(IEnumerable<KeyValuePair<float, DateTime>> psaAndDates)
        {
            // output
            float? result = null;
            // validation
            psaAndDates = psaAndDates.Where(p => p.Key > 0);
            if (psaAndDates.Count() >= 2)
            {
                Caisis.Nomogram.Prostate.PSADoublingTime psaDbl = new Caisis.Nomogram.Prostate.PSADoublingTime();
                foreach (var p in psaAndDates)
                {
                    psaDbl.AddPSA(p.Key, p.Value);
                }
                result = psaDbl.CalculateVelocity().doublingTimeMonth;
            }
            return result;
        }

        /// <summary>
        /// Returns the Pathology(key) AND (ProstatectomyPathology OR BiopsyProstatePathology)(value) used for calulating gleason score.
        /// </summary>
        /// <param name="patientProtocolId"></param>
        /// <returns></returns>
        public static KeyValuePair<Pathology, BusinessObject>? GetGleasonPathologyRecord(int patientProtocolId)
        {
            Pathology path = PatientProtocolController.GetPatientRelatedRecords<Pathology>(patientProtocolId).FirstOrDefault();
            if (path != null && !path.IsEmpty)
            {
                int pathologyId = (int)path[Pathology.PathologyId];
                string pathType = path[Pathology.PathSpecimenType].ToString();
                // manuall set child records
                if (pathType.Equals("Prostatectomy"))
                {
                    var prostatectomy = BusinessObject.GetByParent<ProstatectomyPathology>(pathologyId).FirstOrDefault();
                    if (prostatectomy != null)
                    {
                        return new KeyValuePair<Pathology, BusinessObject>(path, prostatectomy);
                    }
                }
                else if (pathType == "Biopsy")
                {
                    var biopsy = BusinessObject.GetByParent<BiopsyProstatePathology>(pathologyId).FirstOrDefault();
                    if (biopsy != null)
                    {
                        return new KeyValuePair<Pathology, BusinessObject>(path, biopsy);
                    }
                }
            }
            return null;
        }

        /// <summary>
        /// Returns if the StudyId is generated by organization
        /// </summary>
        /// <returns></returns>
        public static bool GenerateStudyIdByOrganization()
        {
            var protocolConfiguration = GetProtocolConfigurationNode();
            if (protocolConfiguration != null)
            {
                XmlNode studyIdNode = protocolConfiguration.SelectSingleNode("//CustomStudyId");
                if (studyIdNode != null)
                {
                    return bool.Parse(studyIdNode.InnerText.Trim());
                }
            }
            return false;
        }

        #region RANDOMIZE TRIALS

        public static IDictionary<int, int> GetRandomizeTrialBucket(int protocolId)
        {
            Dictionary<int, int> _bucket = new Dictionary<int, int>();
            var protocolConfiguration = GetProtocolConfigurationNode();
            if (protocolConfiguration != null)
            {
                // get protocol details
                DataView protocolView = BusinessObject.GetByFieldsAsDataView<Protocol>(new Dictionary<string, object> { { Protocol.ProtocolId, protocolId } });
                // get schemas
                DataView schemas = ProtocolMgmtDa.GetSchemasByProtocol(protocolId).DefaultView;
                schemas.Sort = ProtocolSchema.ProtocolSchemaId + " ASC";
                // read config
                var xDoc = XmlUtil.GetModulesConfigXml();
                // get a list of protocols to match and weights
                var protocolMatchNodes = xDoc.SelectNodes("//module[@name='Protocol Management']//randomization//protocol");
                var protocolMatches = from node in protocolMatchNodes.Cast<XmlNode>()
                                      let matchProtocol = node.Attributes["matchProtocol"].Value
                                      let matchVersion = node.Attributes["matchVersion"] != null ? node.Attributes["matchVersion"].Value : ""
                                      let schemasNodes = node.SelectNodes("//schema").Cast<XmlNode>()
                                      where schemasNodes.Count() > 0
                                      select new
                                      {
                                          MatchProtocol = matchProtocol,
                                          MatchVersion = matchVersion,
                                          Weights = from s in schemasNodes
                                                    select new
                                                    {
                                                        SchemaName = s.Attributes["name"].Value,
                                                        Weight = int.Parse(s.Attributes["weight"].Value)
                                                    }
                                      };
                // find match
                // default weights (1)
                _bucket = new Dictionary<int, int>();
                foreach (var protocolMatch in protocolMatches)
                {
                    // match Protocol (required)
                    protocolView.RowFilter = protocolMatch.MatchProtocol;
                    if (protocolView.Count > 0)
                    {
                        // match Version (optional)
                        schemas.RowFilter = !string.IsNullOrEmpty(protocolMatch.MatchVersion) ? protocolMatch.MatchVersion : string.Empty;
                        if (schemas.Count > 0)
                        {
                            var schemaAndIds = from row in schemas.Cast<DataRowView>()
                                               select new
                                               {
                                                   SchemaId = (int)row[ProtocolSchema.ProtocolSchemaId],
                                                   SchemaName = row[ProtocolSchema.ProtocolArmDescription].ToString()
                                               };
                            var match = from schema in schemaAndIds
                                        join w in protocolMatch.Weights on schema.SchemaName equals w.SchemaName
                                        select new
                                        {
                                            SchemaId = schema.SchemaId,
                                            Weight = w.Weight
                                        };
                            // set weights
                            if (match.Count() > 0)
                            {
                                foreach (var m in match)
                                {
                                    _bucket.Add(m.SchemaId, m.Weight);
                                }
                                // end config search
                                break;
                            }
                        }
                    }

                }
                /*
                // build bucket of schema -> weight: !important: fill bucket only within valid indexes
                int length = Math.Min(schemas.Count, _weights.Length);
                for (int i = 0; i < length; i++)
                {
                    int schemaId = (int)schemas[i][ProtocolSchema.ProtocolSchemaId];
                    int weight = _weights[i];
                    /*
                    // normalize max accrued schemas = 0 weight
                    schemas.RowFilter = ProtocolSchema.ProtocolSchemaId + " = " + schemaId + " AND IsMaxAccrual > 0";
                    if (schemas.Count > 0)
                    {
                        weight = 0;
                    }
                     
                    // !import: reset filter
                    schemas.RowFilter = string.Empty;
                    _bucket.Add(schemaId, weight);
                }
                 */

                // DEFAULT (1):
                if (_bucket.Count == 0)
                {
                    schemas.RowFilter = string.Empty;
                    _bucket = schemas.Cast<DataRowView>().ToDictionary(row => (int)row[ProtocolSchema.ProtocolSchemaId], row => 1);
                }
            
            }
            // return bucket
            return _bucket;
        }

        public static int? RandomizeTrial(int protocolId)
        {
            var bucket = GetRandomizeTrialBucket(protocolId);
            return RandomizeTrial(bucket);
        }

        public static int? RandomizeTrial(IDictionary<int, int> bucket)
        {
            if (bucket.Count > 0)
            {
                return RandomizeTrial<int>(bucket, DateTime.Now.Millisecond);
            }
            return null;
        }

        // TODO: centralize utility
        public static T RandomizeTrial<T>(IDictionary<T, int> bucket, int seed)
        {
            // create a pool of objects with n instances by weight
            var pool = bucket.SelectMany(a => Enumerable.Range(0, a.Value).Select(b => a.Key)).ToArray();
            // select random index and return object
            int random = new Random(seed).Next(0, pool.Length - 1);
            return pool[random];
        }

        #endregion

        #region DATA EXPORT

        /// <summary>
        /// Gets if Patient export is avilable for the given trial
        /// </summary>
        /// <param name="protocolId"></param>
        /// <returns></returns>
        public static bool EnablePatientExport(int protocolId)
        {
            bool enableExport = false;
            // get protocol details
            DataView protocolView = BusinessObject.GetByFieldsAsDataView<Protocol>(new Dictionary<string, object> { { Protocol.ProtocolId, protocolId } });
            XmlNode config = GetProtocolConfigurationNode();
            if (config != null)
            {
                XmlNode matchNode = config.SelectSingleNode("//EnablePatientExport/Protocol[@match]");
                if (matchNode != null)
                {
                    string protocolFilter = matchNode.Attributes["match"].Value;
                    protocolView.RowFilter = protocolFilter;
                    enableExport = protocolView.Count > 0;
                }
            }

            return enableExport;
        }

        #endregion
    }
}